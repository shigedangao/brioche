use rand::prelude::*;
use std::sync::LazyLock;

// Constant
const RGB_VALUE: f64 = 255.;

// ColorType enum to define the type of color that is requested.
pub enum ColorType {
    Rgb,
    Bgr,
}

// Default colors available
pub static COLORS: LazyLock<Vec<(f64, f64, f64)>> = LazyLock::new(|| {
    vec![
        (0.000, 0.447, 0.741),
        (0.850, 0.325, 0.098),
        (0.929, 0.694, 0.125),
        (0.494, 0.184, 0.556),
        (0.466, 0.674, 0.188),
        (0.301, 0.745, 0.933),
        (0.635, 0.078, 0.184),
        (0.300, 0.300, 0.300),
        (0.600, 0.600, 0.600),
        (1.000, 0.000, 0.000),
        (1.000, 0.500, 0.000),
        (0.749, 0.749, 0.000),
        (0.000, 1.000, 0.000),
        (0.000, 0.000, 1.000),
        (0.667, 0.000, 1.000),
        (0.333, 0.333, 0.000),
        (0.333, 0.667, 0.000),
        (0.333, 1.000, 0.000),
        (0.667, 0.333, 0.000),
        (0.667, 0.667, 0.000),
        (0.667, 1.000, 0.000),
        (1.000, 0.333, 0.000),
        (1.000, 0.667, 0.000),
        (1.000, 1.000, 0.000),
        (0.000, 0.333, 0.500),
        (0.000, 0.667, 0.500),
        (0.000, 1.000, 0.500),
        (0.333, 0.000, 0.500),
        (0.333, 0.333, 0.500),
        (0.333, 0.667, 0.500),
        (0.333, 1.000, 0.500),
        (0.667, 0.000, 0.500),
        (0.667, 0.333, 0.500),
        (0.667, 0.667, 0.500),
        (0.667, 1.000, 0.500),
        (1.000, 0.000, 0.500),
        (1.000, 0.333, 0.500),
        (1.000, 0.667, 0.500),
        (1.000, 1.000, 0.500),
        (0.000, 0.333, 1.000),
        (0.000, 0.667, 1.000),
        (0.000, 1.000, 1.000),
        (0.333, 0.000, 1.000),
        (0.333, 0.333, 1.000),
        (0.333, 0.667, 1.000),
        (0.333, 1.000, 1.000),
        (0.667, 0.000, 1.000),
        (0.667, 0.333, 1.000),
        (0.667, 0.667, 1.000),
        (0.667, 1.000, 1.000),
        (1.000, 0.000, 1.000),
        (1.000, 0.333, 1.000),
        (1.000, 0.667, 1.000),
        (0.333, 0.000, 0.000),
        (0.500, 0.000, 0.000),
        (0.667, 0.000, 0.000),
        (0.833, 0.000, 0.000),
        (1.000, 0.000, 0.000),
        (0.000, 0.167, 0.000),
        (0.000, 0.333, 0.000),
        (0.000, 0.500, 0.000),
        (0.000, 0.667, 0.000),
        (0.000, 0.833, 0.000),
        (0.000, 1.000, 0.000),
        (0.000, 0.000, 0.167),
        (0.000, 0.000, 0.333),
        (0.000, 0.000, 0.500),
        (0.000, 0.000, 0.667),
        (0.000, 0.000, 0.833),
        (0.000, 0.000, 1.000),
        (0.000, 0.000, 0.000),
        (0.143, 0.143, 0.143),
        (0.857, 0.857, 0.857),
        (1.000, 1.000, 1.000),
    ]
});

/// Generate a random color based on the specified color type and maximum value.
///
/// # Arguments
/// * `kind` - The type of color that is requested.
/// * `maximum` - The maximum value that can be used for the color.
///
/// # Returns
/// An `Option` containing the generated color as a tuple of three `f64` values.
pub fn random_colors(kind: ColorType, maximum: Option<usize>) -> Option<(f64, f64, f64)> {
    let mut rng = rand::rng();

    let value = rng.random_range(0..COLORS.len());
    let color = COLORS
        .get(value)
        .and_then(|(r, g, b)| Some((r * RGB_VALUE, g * RGB_VALUE, b * RGB_VALUE)));

    if let Some((r, g, b)) = color {
        return match kind {
            ColorType::Rgb => Some((r, g, b)),
            ColorType::Bgr => Some((b, g, r)),
        };
    }

    None
}
